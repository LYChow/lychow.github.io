<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="google7dbb8a5329ef9b78.html" />










  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="C++语法规则优先级:后置++ &amp;gt; 前置++ &amp;gt;乘除

void fun(int i,int i=1);//函数原型正确
void fun1(int i=1,int j);//函数原型错误

1234567int a=3; //全局变量int main()&amp;#123;int a =8;cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl; //同名变量,局部变量优先级高于全局变量&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp Grammar(第10周Summary的课题)">
<meta property="og:url" content="www.coderlychow.com/2016/10/30/Week10_Cpp-Grammar/index.html">
<meta property="og:site_name" content="For Life in Permanent Beta">
<meta property="og:description" content="C++语法规则优先级:后置++ &amp;gt; 前置++ &amp;gt;乘除

void fun(int i,int i=1);//函数原型正确
void fun1(int i=1,int j);//函数原型错误

1234567int a=3; //全局变量int main()&amp;#123;int a =8;cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl; //同名变量,局部变量优先级高于全局变量&amp;#12">
<meta property="og:updated_time" content="2016-10-30T09:51:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cpp Grammar(第10周Summary的课题)">
<meta name="twitter:description" content="C++语法规则优先级:后置++ &amp;gt; 前置++ &amp;gt;乘除

void fun(int i,int i=1);//函数原型正确
void fun1(int i=1,int j);//函数原型错误

1234567int a=3; //全局变量int main()&amp;#123;int a =8;cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl; //同名变量,局部变量优先级高于全局变量&amp;#12">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="www.coderlychow.com/2016/10/30/Week10_Cpp-Grammar/"/>

  <title> Cpp Grammar(第10周Summary的课题) | For Life in Permanent Beta </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '84595258', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">For Life in Permanent Beta</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">the trick is to never stop starting.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'WFjz5j_iq3KdG8zjmBXr','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Cpp Grammar(第10周Summary的课题)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-30T17:48:40+08:00" content="2016-10-30">
              2016-10-30
            </time>
          </span>

          

          
            
          

          

          
          
             <span id="/2016/10/30/Week10_Cpp-Grammar/" class="leancloud_visitors" data-flag-title="Cpp Grammar(第10周Summary的课题)">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">visitors </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="C-语法规则"><a href="#C-语法规则" class="headerlink" title="C++语法规则"></a>C++语法规则</h2><p>优先级:后置++ &gt; 前置++ &gt;乘除</p>
<blockquote>
<p>void fun(int i,int i=1);//函数原型正确</p>
<p>void fun1(int i=1,int j);//函数原型错误</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int a=3; //全局变量</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">int a =8;</div><div class="line">cout&lt;&lt;a&lt;&lt;endl; //同名变量,局部变量优先级高于全局变量</div><div class="line">&#125;</div><div class="line">//如果想使用全局变量而不是局部变量,应在变量前加上作用域运算符&quot;::&quot;即可.</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="变量的存储类型-C-程序运行时使用的内存区域"><a href="#变量的存储类型-C-程序运行时使用的内存区域" class="headerlink" title="变量的存储类型,C++程序运行时使用的内存区域"></a>变量的存储类型,C++程序运行时使用的内存区域</h3><table>
<thead>
<tr>
<th>堆区</th>
<th>存放动态分配的数据,new出来的</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈区</td>
<td>存放局部数据,局部变量</td>
</tr>
<tr>
<td>全局数据区</td>
<td>存放全局数据和静态数据,全局变量</td>
</tr>
<tr>
<td>程序代码区</td>
<td>存放程序各个函数的代码</td>
</tr>
</tbody>
</table>
<blockquote>
<p>所有共用成员函数代码区对象中的函数成员共用一个存储空间,在代码区存放.</p>
</blockquote>
<h3 id="存储类型-auto-register-static-extern"><a href="#存储类型-auto-register-static-extern" class="headerlink" title="存储类型 auto,register,static,extern"></a>存储类型 auto,register,static,extern</h3><blockquote>
<p>一个变量完整形式</p>
<p>&lt;存储类型&gt; &lt;数据类型&gt; &lt;变量名&gt;;</p>
</blockquote>
<ul>
<li>auto:在定义块的开始分配空间,执行结束时释放空间,函数的自动变量(auto)是在函数执行中才分配.</li>
<li>register:尽可能存放在CPU的寄存器中,提高程序的效率,仅局部变量和形式参数才可作为寄存器变量.</li>
<li>static变量是在编译时才分配的内存.如果在全局变量前加上static修饰符,则成为静态全局变量,只能在本文件中使用</li>
<li>extern:如果在一个源文件a.cpp中定义的全局变量想在b.cpp文件中使用,则应该在b.cpp中使用,则应该在b.cpp中加上extern进行声明,表示该全局变量不在b.cpp中定义的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.cpp</div><div class="line">int Dimension =100;</div><div class="line"></div><div class="line">b.cpp</div><div class="line">使用的话,应该声明如下</div><div class="line">extern int Dimension;</div></pre></td></tr></table></figure>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="amp-按位”与”"><a href="#amp-按位”与”" class="headerlink" title="&amp;按位”与”"></a>&amp;按位”与”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=01101001B</div><div class="line">b=01011110B //&amp;,全1为1全0为0</div><div class="line">c=01001000B</div></pre></td></tr></table></figure>
<h3 id="按位”或”"><a href="#按位”或”" class="headerlink" title="|按位”或”"></a>|按位”或”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=01101001B</div><div class="line">b=01011110B  //|,有1为1其他为0</div><div class="line">c=01111111B</div></pre></td></tr></table></figure>
<h3 id="按位异或"><a href="#按位异或" class="headerlink" title="^按位异或"></a>^按位异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a=01101001B</div><div class="line">b=01011110B //^,不同为1,相同为0</div><div class="line">c=00110111B</div></pre></td></tr></table></figure>
<h3 id="按位取反"><a href="#按位取反" class="headerlink" title="~按位取反"></a>~按位取反</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//如:整数是4个字节占32位,补全之后对应位取反</div></pre></td></tr></table></figure>
<h2 id="字符的处理"><a href="#字符的处理" class="headerlink" title="字符的处理"></a>字符的处理</h2><blockquote>
<p>字符串占的字节数=字符串的长度+1.如”程序设计”(4个汉子占8个字节),末尾加了一个结束符’\0’,所有+1个字符.</p>
</blockquote>
<h3 id="有些ASCII符号是不可显示的-如转义字符"><a href="#有些ASCII符号是不可显示的-如转义字符" class="headerlink" title="有些ASCII符号是不可显示的,如转义字符:"></a>有些ASCII符号是不可显示的,如转义字符:</h3><h4 id="n-换行符-r-回车-b-退格符-t-制表符-’-单引号-’’双引号-0-字符串结束符-f-分页符"><a href="#n-换行符-r-回车-b-退格符-t-制表符-’-单引号-’’双引号-0-字符串结束符-f-分页符" class="headerlink" title="\n 换行符  ,\r 回车, \b  退格符,\t 制表符 ,\’ 单引号, \’’双引号, \0 字符串结束符, \f 分页符."></a>\n 换行符  ,\r 回车, \b  退格符,\t 制表符 ,\’ 单引号, \’’双引号, \0 字符串结束符, \f 分页符.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char *strcat(char *destin,char *source) //链接两个字符</div><div class="line">char *strcpy(char *destin,char *source)//将字符串source拷贝到destin中</div><div class="line">char *strlwr(char *string) //string转换成小写</div><div class="line">char *strupr(char *string)//string转换成大写</div><div class="line">String text =&quot;heavy rains are pushing water&quot;;</div><div class="line">k = text.find(&quot;heavy&quot;);</div><div class="line">text.erase(k,sizeof(&quot;heavy&quot;)-1);</div><div class="line">text.insert(k,&quot;strong&quot;);</div></pre></td></tr></table></figure>
<h2 id="指针-and-amp"><a href="#指针-and-amp" class="headerlink" title="指针(*and&amp;)"></a>指针(*and&amp;)</h2><blockquote>
<p>1.我们将存放地址的变量称为指针变量,这里的地址就是指针,指针也是数据类型.</p>
<p>2.*是指针类型变量的标识符</p>
<p>3.定义一个指针变量系统为该指针变量分配一定大小的内存(C++中,每个指针变量占有8个字节长度)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">int a,*pta;//先定义变量</div><div class="line"></div><div class="line">pta = &amp;a;不可写成 *pta=&amp;a;</div><div class="line"></div><div class="line">/*</div><div class="line">*pta并不表示指针变量pta.而表示pta指向的变量a.指针变量和指针变量所指向的变量完全是不同的概念.</div><div class="line"></div><div class="line">&amp;取地址运算符,&amp;变量名 //获取变量的内存单元地址</div><div class="line"></div><div class="line">*指针运算符(间接访问运算符)</div><div class="line"></div><div class="line">指针变量pta存放着变量a的指针,则*pta表示pta所指向的变量,即变量a.</div><div class="line">*/</div><div class="line"></div><div class="line">int a =5; *p =&amp;a;</div><div class="line"></div><div class="line">cout&lt;&lt;&amp;a&lt;&lt;endl;//a的地址</div><div class="line"></div><div class="line">cout&lt;&lt;a&lt;&lt;endl;//变量a的值</div><div class="line"></div><div class="line">cout&lt;&lt;*p&lt;&lt;endl;//p指向的变量</div><div class="line"></div><div class="line">//函数在编译时被分配了一个入口地址,这个入口地址就称为函数的指针.</div><div class="line"></div><div class="line">char name1[50];</div><div class="line"></div><div class="line">//name1是字符数组name1的首地址,也就是&amp;name1[0];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//指针+/-整数----&gt;指针</div><div class="line"></div><div class="line">假设:int a[10] =&#123;10,20,30&#125;,*p=a,i;</div><div class="line"></div><div class="line">p+i:表示p所指元素之后的第i个元素的指针,p指向的是int类型,int类型变量为4个字节长度,</div><div class="line"></div><div class="line">所以p+1,相当于指针P+4,p+i相当于p+4*i</div><div class="line"></div><div class="line">1000 |10</div><div class="line"></div><div class="line">1004 |20</div><div class="line"></div><div class="line">1008 |30</div><div class="line"></div><div class="line">100C |...</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//同类型的指针做减法运算</div><div class="line"></div><div class="line">//指针2-指针1 ---&gt;整数,常用于计算两个指针间包含元素的个数.</div><div class="line"></div><div class="line">(指针2-指针1)/元素字节长度 =元素个数</div><div class="line"></div><div class="line">int a[];*p=a,i;</div><div class="line"></div><div class="line">a+i表示对象的地址</div><div class="line"></div><div class="line">*(a+i)表示指向的对象</div><div class="line"></div><div class="line">char str[81],*pstr;</div><div class="line"></div><div class="line">str =&apos;abcd&apos;;错误,数组名是常量指针!不能被赋值</div></pre></td></tr></table></figure>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><blockquote>
<p>结构体变量的指针           &amp;结构体变量名</p>
<p>指向结构体变量的指针    结构体类型  *指针变量名</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct telelist&#123;</div><div class="line">char name[8];</div><div class="line">char sex;</div><div class="line">char num[15];</div><div class="line">char num2[15];</div><div class="line">&#125;List[3];</div><div class="line">//表示list包含telelist这种格式的3个元素</div></pre></td></tr></table></figure>
<h3 id="结构体指针访问结构体中变量中的成员"><a href="#结构体指针访问结构体中变量中的成员" class="headerlink" title="结构体指针访问结构体中变量中的成员"></a>结构体指针访问结构体中变量中的成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.(*指针变量).成员名</div><div class="line">2.指针变量-&gt;成员名  //-&gt;称为结构体指向运算符</div><div class="line">例如:</div><div class="line">Date d = &#123;2015,4,8&#125;,*p = &amp;d; //定义日期结构体变量和指针变量</div><div class="line">(*p).year  p-&gt;year</div></pre></td></tr></table></figure>
<h3 id="delete运算符-释放动态申请到的存储空间"><a href="#delete运算符-释放动态申请到的存储空间" class="headerlink" title="delete运算符:释放动态申请到的存储空间"></a>delete运算符:释放动态申请到的存储空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.动态释放单个变量</div><div class="line">delete 指针变量 ; //释放单个动态变量</div><div class="line"></div><div class="line">2.动态释放数组</div><div class="line">delete []指针变量 ;//释放动态数组</div></pre></td></tr></table></figure>
<h3 id="new运算符-gt-动态申请所需的内存空间"><a href="#new运算符-gt-动态申请所需的内存空间" class="headerlink" title="new运算符-&gt;动态申请所需的内存空间"></a>new运算符-&gt;动态申请所需的内存空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1.动态申请单个变量</div><div class="line">指针变量 = new 类型;</div><div class="line">double *p;</div><div class="line">p= new double(100.0);</div><div class="line"></div><div class="line">2.动态申请数组</div><div class="line">指针变量 = new 类型[元素个数];</div><div class="line">char *str;</div><div class="line">str =new char[80];</div><div class="line">cin&gt;&gt;n; p = new int [n];</div><div class="line">if(p=NULL)&#123;</div><div class="line">cout&lt;&lt;&quot;空间申请失败!&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="抽象-amp-封装"><a href="#抽象-amp-封装" class="headerlink" title="抽象&amp;封装"></a>抽象&amp;封装</h2><h3 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别?"></a>结构体和类的区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.结构体只有数据成员没有函数成员.</div><div class="line">2.类=数据成员+函数成员</div><div class="line">3.结构体又称为特殊的类,现在的结构体中也可以包含函数成员</div></pre></td></tr></table></figure>
<h3 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.内联函数"></a>1.内联函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在类体内直接定义的函数成员,该函数成员又称为内联函数</div><div class="line"></div><div class="line">Class clock&#123;</div><div class="line">void show_Time()&#123;cout&lt;&lt;hour:&lt;&lt;:&lt;&lt;minute&lt;&lt;endl;&#125; //内联函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline int square(int x)</div><div class="line">&#123;</div><div class="line">return x*x;</div><div class="line">&#125;</div><div class="line">int sum =0;</div><div class="line">sum+=square(i);</div><div class="line"></div><div class="line">//编译时遇到内联函数调用square(i),实参换形参,sum+=square(i);将被替换为sum+=i*i;</div></pre></td></tr></table></figure>
<h3 id="2-在类体外定义函数成员"><a href="#2-在类体外定义函数成员" class="headerlink" title="2.在类体外定义函数成员"></a>2.在类体外定义函数成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;类型&gt;&lt;类名&gt; :: &lt;函数名&gt;(&lt;参数列表&gt;)</div><div class="line">&#123;</div><div class="line">&lt;函数体&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//::表示作用域符号</div></pre></td></tr></table></figure>
<h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><blockquote>
<p>以功能为中心,通过分解问题的功能,采用函数描述数据与函数分离,数据(类型或结构)发生变化,函数也要发生相应变化.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如 void sort(int a[],int n);//只能排整数的数组</div></pre></td></tr></table></figure>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><blockquote>
<p>以数据为中心,采用对象来描述内部属性和操作方法,将数据和函数当做一个统一体,采用软件对象来描述客观对象.</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote>
<p>构造函数,用于创建一个对象,提供了初始化该对象的手段.成员函数完成初始化数据成员.</p>
<p>constructor 在对象创建时执行,提供了初始化对象的一种简便手段.</p>
<p>Destructor 在对象被撤销时(前)执行,用于完成对象被销毁前的一些清理工作.</p>
<p>往往用于释放constructor中动态申请的内存空间.</p>
</blockquote>
<h3 id="Destructor-语法格式"><a href="#Destructor-语法格式" class="headerlink" title="Destructor 语法格式"></a>Destructor 语法格式</h3><blockquote>
<p>&lt;类名&gt;::~&lt;类名&gt;(){&lt;函数体&gt;}</p>
<p>功能:撤销对象前进行一些善后处理工作,由系统调用.类名前加~.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Class robot&#123;</div><div class="line">robot();//构造函数</div><div class="line">&#123;</div><div class="line">strcpy(name,&quot;xx&quot;);</div><div class="line">strcpy(type,&quot;xx&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void set(char n[],char t[],int m); //设置修改数据</div><div class="line">~robot()&#123;delete []ps;&#125; //释放构造函数和set函数中动态申请的空间</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承(inheritance)"></a>继承(inheritance)</h2><blockquote>
<p>从以前定义的类(基类)产生新类的过程为派生,新产生的类为派生类</p>
</blockquote>
<h3 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义"></a>派生类的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class 派生类名 :继承方式(即是访问权限) 基类名1</div><div class="line">Class singStar:public Person</div><div class="line">//对基类的扩充/对基类成员的改造,系统默认就是私有继承</div></pre></td></tr></table></figure>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li>public(基类共有成员,基类保护成员)</li>
<li>protected(基类的public和protected成员相当于派生类的保护成员,派生类可以通过子类和自身的成员函数访问他们)</li>
<li>private(基类的public和protected成员相当于派生类的私有成员,派生类只能通过函数成员访问)</li>
</ul>
<h3 id="基类的constructor和destructor不能被继承"><a href="#基类的constructor和destructor不能被继承" class="headerlink" title="基类的constructor和destructor不能被继承"></a>基类的constructor和destructor不能被继承</h3><blockquote>
<p>派生类的构造函数一般形式为</p>
<p>派生类名::派生类名(参数列表):基类名1(参数列表1)…内嵌对象名(对象参数表)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Class Employee:public Person</div><div class="line">&#123;</div><div class="line">Person lerader;//内嵌对象</div><div class="line">char Dept[20];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Employee(char *name,int age,char *dept,char name,int age):Person(name,age),Leader(name1,age1)</div><div class="line"></div><div class="line">Cylinder::cylinder(int x,int y,double r,double h):Circle(x,y,r);</div></pre></td></tr></table></figure>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<p>相同语法结构,代表不同的功能和操作,一种接口多种方法</p>
</blockquote>
<ul>
<li>编译时多态性:编译器对源程序编译时可以确定调用哪一个函数,通过重载实现(参数类型不同)</li>
<li>运行时多态性:在运行过程中确定调用哪一个函数,通过虚函数来实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dog,cat:Pet</div><div class="line">pet pet1;</div><div class="line">*p = &amp;pet1;</div><div class="line">cin&gt;&gt;x;</div><div class="line">if(x==1) p = &amp;cat1;</div><div class="line">if(x==2) p = &amp;dog1;</div><div class="line">p-&gt;speak();//只有运行时才知道,究竟运行哪个函数</div><div class="line">Class Pet&#123;</div><div class="line">public;</div><div class="line">virtual void speak()&#123;</div><div class="line">cout&lt;&lt;&quot;222&quot;&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">//virtual使得speak为虚函数,实现基类指针访问派生类的成员函数.</div></pre></td></tr></table></figure>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h4 id="基类加入virtual的函数是虚函数-子类可以重写虚函数实现对父函数的覆盖"><a href="#基类加入virtual的函数是虚函数-子类可以重写虚函数实现对父函数的覆盖" class="headerlink" title="基类加入virtual的函数是虚函数,子类可以重写虚函数实现对父函数的覆盖."></a>基类加入virtual的函数是虚函数,子类可以重写虚函数实现对父函数的覆盖.</h4><blockquote>
<p>当想用派生类的成员函数取代基类的同名函数时,C++要求你必须预先通知编译器.通知的方法就是在可能被取代的基类成员函数前面加上virtual关键字.</p>
</blockquote>
<h4 id="在计算机领域virtual的意思是用户看到的东西事实上并不存在-它只是用某种方法支撑的幻觉罢了-这里他的意思是不让用户看到事实上存在的东西-基类的成员函数"><a href="#在计算机领域virtual的意思是用户看到的东西事实上并不存在-它只是用某种方法支撑的幻觉罢了-这里他的意思是不让用户看到事实上存在的东西-基类的成员函数" class="headerlink" title="在计算机领域virtual的意思是用户看到的东西事实上并不存在,它只是用某种方法支撑的幻觉罢了.这里他的意思是不让用户看到事实上存在的东西(基类的成员函数)."></a>在计算机领域virtual的意思是用户看到的东西事实上并不存在,它只是用某种方法支撑的幻觉罢了.这里他的意思是不让用户看到事实上存在的东西(基类的成员函数).</h4><blockquote>
<p>virtual可以替换成另外一个关键字会更加确切choose_the_appropriate_method_at_runtime_for_whatever_object_this_is(在运行时根据对象的类型选择合适的成员函数),这里也可以替换成一个更简单的词placeholder.</p>
</blockquote>
<h4 id="不管怎么如果需要调用基类的成员函数可以使用下面的方法"><a href="#不管怎么如果需要调用基类的成员函数可以使用下面的方法" class="headerlink" title="不管怎么如果需要调用基类的成员函数可以使用下面的方法:"></a>不管怎么如果需要调用基类的成员函数可以使用下面的方法:</h4><blockquote>
<p>p-&gt;Fruit::peel();</p>
</blockquote>
<h4 id="为什么成员函数不缺省使用virtual"><a href="#为什么成员函数不缺省使用virtual" class="headerlink" title="为什么成员函数不缺省使用virtual?"></a>为什么成员函数不缺省使用virtual?</h4><blockquote>
<p>不能缺省virtual的原因和C语言不能缺省使用register关键字有异曲同工之妙,它是一种笨拙的优化措施.既然不是每个成员函数都需要这种运行时的间接形式,那为什么要让每一个成员函数都添加一个额外的负担呢?应该显示的告诉编译器哪些成员函数需要多态.</p>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><blockquote>
<p>函数定义的头部加上virtual,该函数就是虚函数.在基类中声明为virtual并在派生类中重新定义的同名函数,成为虚函数.</p>
</blockquote>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式:"></a>格式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">virtual 函数返回类型 函数名(参数列表)&#123;</div><div class="line">函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用处"><a href="#用处" class="headerlink" title="用处:"></a>用处:</h3><blockquote>
<p>实现运行时的多态性,通过基类指针访问派生类中的同名覆盖函数</p>
</blockquote>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制:"></a>使用限制:</h3><blockquote>
<p>应该通过指针或引用调用虚函数,而不能以对象名调用虚函数.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pet obj;</div><div class="line">Dog dog1;</div><div class="line">obj =dog1;</div><div class="line">obj.speak();//执行基类的speak()函数</div><div class="line">Pet *pet1 =&amp;dog1;</div><div class="line">pet1-&gt;speak(); //执行是Dog类的speak()函数.</div><div class="line">//在派生类重定义基类的虚函数仍为虚函数,同时可省略virtual关键字.</div><div class="line">//不能定义虚constructor函数,可以定义虚destructor函数.</div></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>将那些并不用来声明对象(实例化)的类称为抽象类,只供继承.</li>
<li>具体实现只能在派生类中完成,抽象类又可以定义成:至少包含一个纯虚函数的类,虚函数是多态的一种形式,作用是实现函数的覆盖.</li>
</ul>
<h3 id="纯虚函数定义"><a href="#纯虚函数定义" class="headerlink" title="纯虚函数定义:"></a>纯虚函数定义:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtual  返回类型  函数名(参数列表) = 0</div></pre></td></tr></table></figure>
<h3 id="虚析构函数-通过基类指针可以释放派生类对象的空间"><a href="#虚析构函数-通过基类指针可以释放派生类对象的空间" class="headerlink" title="虚析构函数:通过基类指针可以释放派生类对象的空间."></a>虚析构函数:通过基类指针可以释放派生类对象的空间.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Class Base&#123;</div><div class="line">void show();</div><div class="line">virtual void Base::show&#123;cout&lt;&lt;x&lt;&lt;endl;&#125; //调用时说明virtual虚函数是不正确的</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class Base</div><div class="line">&#123;</div><div class="line">virtual void show(); //声明</div><div class="line">&#125;</div><div class="line">void Base::show()&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;//类外定义</div></pre></td></tr></table></figure>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="根据函数实参中的类型来确认是否匹配函数模板中对应的形参-然后生成一个重载函数"><a href="#根据函数实参中的类型来确认是否匹配函数模板中对应的形参-然后生成一个重载函数" class="headerlink" title="根据函数实参中的类型来确认是否匹配函数模板中对应的形参,然后生成一个重载函数."></a>根据函数实参中的类型来确认是否匹配函数模板中对应的形参,然后生成一个重载函数.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt; //class指某种类型(char,int,struct)</div><div class="line"></div><div class="line">//类模板定义</div><div class="line">template &lt;class &lt;类型参数&gt;&gt;</div><div class="line">迭代器  确定元素位置的数据类型,可用来遍历容器中的元素,可以读取,修改它指向的元素.</div><div class="line">vector 对动态数组的封装,能够插入元素且能够自动调整容器大小.</div><div class="line">创建10个元素的向量</div><div class="line">vector &lt;String&gt; s2(10);</div><div class="line">v1.Insert(v1.end()-1,3);//倒数第2的位置上插入元素向迭代器</div></pre></td></tr></table></figure>
<h2 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ifstream //对象只进行读操作</div><div class="line">ofstream //对象只进行写操作</div><div class="line">fstream //可读可写</div><div class="line"></div><div class="line">istream &amp; getline(char *pch,int ncount,char delim=&apos;\n&apos;)</div><div class="line">pch:读取多个字符放在pch中,ncount:读取字符的上限,读取字符到delim结束,终止字符被舍弃.</div><div class="line">cin.getline();//将指针移到终止字符之后</div><div class="line">cin.get(); //将指针移到终止字符处</div></pre></td></tr></table></figure>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void open(const char *fileName,openMode mode)</div><div class="line">ifstream in(&quot;file.txt&quot;);</div><div class="line">if(!in) //不可以打开文件</div></pre></td></tr></table></figure>
<h3 id="打开文件用于输入"><a href="#打开文件用于输入" class="headerlink" title="打开文件用于输入"></a>打开文件用于输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifstream file1; file1.open(&quot;grade.txt&quot;);</div></pre></td></tr></table></figure>
<h3 id="打开文件用于输出"><a href="#打开文件用于输出" class="headerlink" title="打开文件用于输出"></a>打开文件用于输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ofstream file2; file2.open(&quot;c:\msg.txt&quot;);</div></pre></td></tr></table></figure>
<h3 id="以二进制的形式打开文件-c-abc-bmp"><a href="#以二进制的形式打开文件-c-abc-bmp" class="headerlink" title="以二进制的形式打开文件 c:\abc.bmp"></a>以二进制的形式打开文件 c:\abc.bmp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fstream file3; file3.open(&quot;c:\abc.bmp&quot;,ios::binary|ios::in);</div></pre></td></tr></table></figure>
<h3 id="二进制文件读写函数"><a href="#二进制文件读写函数" class="headerlink" title="二进制文件读写函数"></a>二进制文件读写函数</h3><h4 id="二进制文件输入数据"><a href="#二进制文件输入数据" class="headerlink" title="二进制文件输入数据"></a>二进制文件输入数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">istream &amp;read(char *buffer,int len);</div></pre></td></tr></table></figure>
<h4 id="二进制文件输出数据"><a href="#二进制文件输出数据" class="headerlink" title="二进制文件输出数据"></a>二进制文件输出数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ostream &amp;write(const char *buffer,int len);</div></pre></td></tr></table></figure>
<h2 id="STL-Standard-Template-Library"><a href="#STL-Standard-Template-Library" class="headerlink" title="STL(Standard Template Library)"></a>STL(Standard Template Library)</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="你有必要包含-maps是std命名空间的一部分-maps需要2到3种类型对于模板"><a href="#你有必要包含-maps是std命名空间的一部分-maps需要2到3种类型对于模板" class="headerlink" title="你有必要包含,maps是std命名空间的一部分,maps需要2到3种类型对于模板"></a>你有必要包含<map>,maps是std命名空间的一部分,maps需要2到3种类型对于模板</map></h4><blockquote>
<p>you will need to include <map> and maps are part of the std <a href="http://www.cprogramming.com/tutorial/namespaces.html" target="_blank" rel="external">namespace</a>. Maps require two, and possibly three, types for the template:</map></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">std::map &lt;key_type, data_type, [comparison_function]&gt;</div><div class="line">std::map &lt;string, char&gt; grade_list;</div><div class="line">grade_list[&quot;John&quot;] = &apos;B&apos;;</div><div class="line">// John&apos;s grade improves</div><div class="line">grade_list[&quot;John&quot;] = &apos;A&apos;;</div></pre></td></tr></table></figure>
<h4 id="需要调用一个erase函数进行删除map中的一个成员"><a href="#需要调用一个erase函数进行删除map中的一个成员" class="headerlink" title="需要调用一个erase函数进行删除map中的一个成员"></a>需要调用一个erase函数进行删除map中的一个成员</h4><blockquote>
<p>requires calling the function erase, which is a member of the map class</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">erase(key_type key_value);</div><div class="line">grade_list.erase(&quot;John&quot;);</div></pre></td></tr></table></figure>
<h4 id="how-many-values-the-map-contains-by-using-the-size-function"><a href="#how-many-values-the-map-contains-by-using-the-size-function" class="headerlink" title="how many values the map contains by using the size function"></a>how many values the map contains by using the size function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int size();</div></pre></td></tr></table></figure>
<h4 id="we-could-call-the-size-function-on-the-grade-list"><a href="#we-could-call-the-size-function-on-the-grade-list" class="headerlink" title="we could call the size function on the grade list:"></a>we could call the size function on the grade list:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">std::cout&lt;&lt;&quot;The class is size &quot;&lt;&lt;grade_list.size()&lt;&lt;std::endl;</div></pre></td></tr></table></figure>
<h4 id="If-we’re-only-interested-in-whether-the-map-is-empty-we-can-just-use-the-map-member-function-empty"><a href="#If-we’re-only-interested-in-whether-the-map-is-empty-we-can-just-use-the-map-member-function-empty" class="headerlink" title="If we’re only interested in whether the map is empty, we can just use the map member function empty:"></a>If we’re only interested in whether the map is empty, we can just use the map member function empty:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool empty();</div></pre></td></tr></table></figure>
<h4 id="If-you-want-guarantee-that-the-map-is-empty-you-can-use-the-clear-function"><a href="#If-you-want-guarantee-that-the-map-is-empty-you-can-use-the-clear-function" class="headerlink" title="If you want guarantee that the map is empty, you can use the clear function."></a>If you want guarantee that the map is empty, you can use the clear function.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grade_list.clear();</div></pre></td></tr></table></figure>
<h4 id="一个key是否在map中有对应的value-你需要调用find函数如果有这个key对应的value时将会返回一个iterator-如果没有发现key对应的value迭代器将会指向这个-map-name-end"><a href="#一个key是否在map中有对应的value-你需要调用find函数如果有这个key对应的value时将会返回一个iterator-如果没有发现key对应的value迭代器将会指向这个-map-name-end" class="headerlink" title="一个key是否在map中有对应的value,你需要调用find函数如果有这个key对应的value时将会返回一个iterator,如果没有发现key对应的value迭代器将会指向这个 map_name.end()"></a>一个key是否在map中有对应的value,你需要调用find函数如果有这个key对应的value时将会返回一个iterator,如果没有发现key对应的value迭代器将会指向这个 <em>map_name</em>.end()</h4><blockquote>
<p>whether a key has an associated value in a map,you need to use the find function, which will return an <a href="http://www.cprogramming.com/tutorial/stl/iterators.html" target="_blank" rel="external">iterator</a> pointing to the value of the element of the map associated with the particular key, or if the key isn’t found, a pointer to the iterator <em>map_name</em>.end()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">std::map &lt;string, char&gt; grade_list;</div><div class="line">grade_list[&quot;John&quot;] = &apos;A&apos;;</div><div class="line">if(grade_list.find(&quot;Tim&quot;) == grade_list.end())</div><div class="line">&#123;</div><div class="line">    std::cout&lt;&lt;&quot;Tim is not in the map!&quot;&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">std::map&lt;parameters&gt;::iterator iterator_name;</div></pre></td></tr></table></figure>
<h4 id="包含两个成员-第一个对应的是key-第二个对应的是value-迭代器被当做是一个指针去访问成员变量-你需要用-gt-去取消引用这个迭代器"><a href="#包含两个成员-第一个对应的是key-第二个对应的是value-迭代器被当做是一个指针去访问成员变量-你需要用-gt-去取消引用这个迭代器" class="headerlink" title="包含两个成员,第一个对应的是key,第二个对应的是value,迭代器被当做是一个指针去访问成员变量,你需要用-&gt;去取消引用这个迭代器"></a>包含两个成员,第一个对应的是key,第二个对应的是value,迭代器被当做是一个指针去访问成员变量,你需要用-&gt;去取消引用这个迭代器</h4><blockquote>
<p>essentially has two members, first and second. First corresponds to the key, second to the value. Note that because an iterator is treated like a pointer, to access the member variables, you need to use the arrow operator, -&gt;, to “dereference” the iterator. </p>
<p>the following sample shows the use of an iterator (pointing to the beginning of a map) to access the key and value.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">std::map &lt;string, char&gt; grade_list;</div><div class="line">grade_list[&quot;John&quot;] = &apos;A&apos;;</div><div class="line">// Should be John</div><div class="line">std::cout&lt;&lt;grade_list.begin()-&gt;first&lt;&lt;endl;</div><div class="line">// Should be A</div><div class="line">std::cout&lt;&lt;grade_list.begin()-&gt;second&lt;&lt;endl;</div></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="向量相对比较花费时间插入向量中-但是能够很快的进行随机访问-链表比较容易插入但是访问比较困难"><a href="#向量相对比较花费时间插入向量中-但是能够很快的进行随机访问-链表比较容易插入但是访问比较困难" class="headerlink" title="向量相对比较花费时间插入向量中,但是能够很快的进行随机访问,链表比较容易插入但是访问比较困难"></a>向量相对比较花费时间插入向量中,但是能够很快的进行随机访问,链表比较容易插入但是访问比较困难</h4><blockquote>
<p>The vector has relatively costly insertions into the middle of the vector, but fast random access, whereas the list allows cheap insertions, but slow access (because the list has to be traversed to reach any item),declares a list storing integers:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">std::list&lt;int&gt; integer_list;</div></pre></td></tr></table></figure>
<h4 id="新的元素将会各自插在链表的开头和结尾用push-back-and-push-front-两个函数"><a href="#新的元素将会各自插在链表的开头和结尾用push-back-and-push-front-两个函数" class="headerlink" title="新的元素将会各自插在链表的开头和结尾用push_back and push_front 两个函数"></a>新的元素将会各自插在链表的开头和结尾用push_back and push_front 两个函数</h4><blockquote>
<p>Like the vector class, the list class includes the push_back and push_front functions, which add new elements to the front or back of the list respectively. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">std::list&lt;int&gt; integer_list;</div><div class="line">integer_list.push_front(1);</div><div class="line">integer_list.push_front(2);</div></pre></td></tr></table></figure>
<h4 id="插入需要一个迭代器指向这个元素应该被插入的位置-新的元素将会被插入当前指向的"><a href="#插入需要一个迭代器指向这个元素应该被插入的位置-新的元素将会被插入当前指向的" class="headerlink" title="插入需要一个迭代器指向这个元素应该被插入的位置,新的元素将会被插入当前指向的"></a>插入需要一个迭代器指向这个元素应该被插入的位置,新的元素将会被插入当前指向的</h4><h4 id="元素之前"><a href="#元素之前" class="headerlink" title="元素之前"></a>元素之前</h4><blockquote>
<p>insert requires an iterator pointing to the position into which the element should be inserted (the new element will be inserted right before the element currently being pointed to will). iterator insert(iterator position, const T&amp; element_to_insert);</p>
</blockquote>
<h4 id="链表返回一个迭代器在链表的第一个元素-返回一个迭代器在元素在链表的最后-你能声明一个迭代器作为其他对象的容器"><a href="#链表返回一个迭代器在链表的第一个元素-返回一个迭代器在元素在链表的最后-你能声明一个迭代器作为其他对象的容器" class="headerlink" title="链表返回一个迭代器在链表的第一个元素,返回一个迭代器在元素在链表的最后,你能声明一个迭代器作为其他对象的容器"></a>链表返回一个迭代器在链表的第一个元素,返回一个迭代器在元素在链表的最后,你能声明一个迭代器作为其他对象的容器</h4><blockquote>
<p>Fortunately, the list container supports both the begin – returning an iterator to the beginning of the list – and end – returning an iterator past the last element of the list – iterator functions, and you can declare iterators as with any other container, in the following manner:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list&lt;type&gt;::iterator iterator_name;</div></pre></td></tr></table></figure>
<h4 id="增加一个元素与在链表的结尾也可以这样实现"><a href="#增加一个元素与在链表的结尾也可以这样实现" class="headerlink" title="增加一个元素与在链表的结尾也可以这样实现:"></a>增加一个元素与在链表的结尾也可以这样实现:</h4><blockquote>
<p>using insert and the function end, the functionality of push_back, which adds an element to the end of the list, could also be implemented as</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::list&lt;int&gt; integer_list;</div><div class="line">integer_list.insert(integer_list.end(), item);</div></pre></td></tr></table></figure>
<h4 id="链表包含两个函数size-empty-size的时间复杂度是O-N-如果你想要测试一个链表是否为空用empty函数代替size函数-如果你想保证这个链表为空-就要用clear函数"><a href="#链表包含两个函数size-empty-size的时间复杂度是O-N-如果你想要测试一个链表是否为空用empty函数代替size函数-如果你想保证这个链表为空-就要用clear函数" class="headerlink" title="链表包含两个函数size,empty,size的时间复杂度是O(N),如果你想要测试一个链表是否为空用empty函数代替size函数,如果你想保证这个链表为空,就要用clear函数"></a>链表包含两个函数size,empty,size的时间复杂度是O(N),如果你想要测试一个链表是否为空用empty函数代替size函数,如果你想保证这个链表为空,就要用clear函数</h4><h4 id="排序算法仅仅提供能随机访问迭代器-不提供排序在链表容器中-这时候就有必要用成员函数进行排序了"><a href="#排序算法仅仅提供能随机访问迭代器-不提供排序在链表容器中-这时候就有必要用成员函数进行排序了" class="headerlink" title="排序算法仅仅提供能随机访问迭代器,不提供排序在链表容器中,这时候就有必要用成员函数进行排序了"></a>排序算法仅仅提供能随机访问迭代器,不提供排序在链表容器中,这时候就有必要用成员函数进行排序了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">instance_name.sort();</div></pre></td></tr></table></figure>
<h4 id="Lists-can-be-reversed-using"><a href="#Lists-can-be-reversed-using" class="headerlink" title="Lists can be reversed using"></a>Lists can be reversed using</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">instance_name.reverse();</div></pre></td></tr></table></figure>
<h4 id="其中一个特点-用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值"><a href="#其中一个特点-用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值" class="headerlink" title="其中一个特点,用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值."></a>其中一个特点,用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值.</h4><blockquote>
<p>Another potentially useful list function is the member function called unique; unique converts a string of equal elements into a single element by removing all but the first element in the sequence. For instance, if you had a list consisting of</p>
</blockquote>
<h4 id="另外一个可能的用法链表的函数是一个成员函数被调用unique-删除链表中相同的元素最后只保留一个-如果你有一个链表包含如下"><a href="#另外一个可能的用法链表的函数是一个成员函数被调用unique-删除链表中相同的元素最后只保留一个-如果你有一个链表包含如下" class="headerlink" title="另外一个可能的用法链表的函数是一个成员函数被调用unique,删除链表中相同的元素最后只保留一个,如果你有一个链表包含如下"></a>另外一个可能的用法链表的函数是一个成员函数被调用unique,删除链表中相同的元素最后只保留一个,如果你有一个链表包含如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 1 8 9 7 8 2 3 3</div></pre></td></tr></table></figure>
<h4 id="the-calling-unique-would-result-in-the-following-output-可以发现仍然还有两个8-仅仅挨着的两个元素其中一个被删除了"><a href="#the-calling-unique-would-result-in-the-following-output-可以发现仍然还有两个8-仅仅挨着的两个元素其中一个被删除了" class="headerlink" title="the calling unique would result in the following output:可以发现仍然还有两个8,仅仅挨着的两个元素其中一个被删除了"></a>the calling unique would result in the following output:可以发现仍然还有两个8,仅仅挨着的两个元素其中一个被删除了</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 8 9 7 8 2 3</div></pre></td></tr></table></figure>
<h4 id="你如果想要把相同的元素只保留一个-就需要先排序再调用unique函数"><a href="#你如果想要把相同的元素只保留一个-就需要先排序再调用unique函数" class="headerlink" title="你如果想要把相同的元素只保留一个,就需要先排序再调用unique函数."></a>你如果想要把相同的元素只保留一个,就需要先排序再调用unique函数.</h4><blockquote>
<p>If you want each element to show up once, and only once, you need to sort the list first! Try the following code to see how this works and see many of the previous functions in action!,</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">std::list&lt;int&gt; int_list;</div><div class="line"></div><div class="line">int_list.push_back(1);</div><div class="line"></div><div class="line">int_list.push_back(1);</div><div class="line"></div><div class="line">int_list.push_back(8);</div><div class="line"></div><div class="line">int_list.push_back(9);</div><div class="line"></div><div class="line">int_list.push_back(7);</div><div class="line"></div><div class="line">int_list.push_back(8);</div><div class="line"></div><div class="line">int_list.push_back(2);</div><div class="line"></div><div class="line">int_list.push_back(3);</div><div class="line"></div><div class="line">int_list.push_back(3);</div><div class="line"></div><div class="line">int_list.sort();</div><div class="line"></div><div class="line">int_list.unique();</div><div class="line"></div><div class="line">for(std::list&lt;int&gt;::iterator list_iter = int_list.begin(); </div><div class="line"></div><div class="line">    list_iter != int_list.end(); list_iter++)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    std::cout&lt;&lt;*list_iter&lt;&lt;endl;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>The Good</strong></p>
<ul>
<li>Lists provide fast insertions (in amortized constant time) at the expensive of lookups (链表能够快速的插入以固定的时间),在查找时比较耗时</li>
<li>Lists support bidirectional iterators, but not random access iterators,链表支持双向的迭代器,但不支持随机读取的迭代器</li>
<li>Iterators on lists tend to handle the removal and insertion of surrounding elements well,链表上的迭代器更倾向于手动插入,删除周围的元素</li>
</ul>
<p><strong>The Gotchas</strong></p>
<ul>
<li>Lists are slow to search, and using the size function will take O(n) time,链表遍历起来非常慢,用size函数的时间复杂度为O(N)</li>
<li>Searching for an element in a list will require O(n) time because it lacks support for random access,遍历一个元素的时间复杂度是O(N),它缺少随机访问的支持</li>
</ul>
<h4 id="容器-amp-迭代器"><a href="#容器-amp-迭代器" class="headerlink" title="容器&amp;迭代器"></a>容器&amp;迭代器</h4><ul>
<li>容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供</li>
</ul>
<ul>
<li>迭代器（Iterator），提供了访问容器中对象的方法。Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</li>
</ul>
<blockquote>
<p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vector&lt;T&gt;::iterator it;</div><div class="line">list&lt;T&gt;::iterator it;deque&lt;T&gt;::iterator it；</div></pre></td></tr></table></figure>
<p>从容器中读取元素。</p>
<ul>
<li>输入迭代器只能一次读入一个元素向前移动，输入迭代器只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列output:向容器中写入元素。</li>
<li>输出迭代器只能一次一个元素向前移动。输出迭代器只支持一遍算法，统一输出迭代器不能两次遍历一个序列</li>
<li>forward:组合输入迭代器和输出迭代器的功能，并保留在容器中的位置bidirectional:组合正向迭代器和逆向迭代器的功能，支持多遍算法random access:组合双向迭代器的功能与直接访问容器中任何元素的功能，即可向前向后跳过任意个元素</li>
</ul>
<h4 id="尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的-include指示符的后面：using-namespace-std"><a href="#尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的-include指示符的后面：using-namespace-std" class="headerlink" title="尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的#include指示符的后面：using namespace std;"></a>尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的#include指示符的后面：using namespace std;</h4><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h4><p><a href="http://www.cprogramming.com/tutorial/stl/stlmap.html" target="_blank" rel="external">http://www.cprogramming.com/tutorial/stl/stlmap.html</a></p>
<p><a href="http://www.cprogramming.com/tutorial/stl/stllist.html" target="_blank" rel="external">http://www.cprogramming.com/tutorial/stl/stllist.html</a></p>
<p><a href="http://www.icourse163.org/course/xjtu-46006#/info" target="_blank" rel="external">计算机程序设计（C++(西安交通大学)</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/23/Week9_tips-about-house-from-lujun/" rel="next" title="tips about house from lujun(第9周Research课题)">
                <i class="fa fa-chevron-left"></i> tips about house from lujun(第9周Research课题)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/30/Week10_reading-skills-from-lixiaolai/" rel="prev" title="reading skills from lixiaolai(第10周Summary的课题)">
                reading skills from lixiaolai(第10周Summary的课题) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="luyao" />
          <p class="site-author-name" itemprop="name">luyao</p>
          <p class="site-description motion-element" itemprop="description">Planning and adapting is being about flexibly persistent:always ready to adapt,but also persistent in driving towards set goals.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LYChow" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/chow_ly" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-语法规则"><span class="nav-number">1.</span> <span class="nav-text">C++语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的存储类型-C-程序运行时使用的内存区域"><span class="nav-number">1.1.</span> <span class="nav-text">变量的存储类型,C++程序运行时使用的内存区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储类型-auto-register-static-extern"><span class="nav-number">1.2.</span> <span class="nav-text">存储类型 auto,register,static,extern</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算符"><span class="nav-number">2.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#amp-按位”与”"><span class="nav-number">2.1.</span> <span class="nav-text">&按位”与”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按位”或”"><span class="nav-number">2.2.</span> <span class="nav-text">|按位”或”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按位异或"><span class="nav-number">2.3.</span> <span class="nav-text">^按位异或</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按位取反"><span class="nav-number">2.4.</span> <span class="nav-text">~按位取反</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符的处理"><span class="nav-number">3.</span> <span class="nav-text">字符的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有些ASCII符号是不可显示的-如转义字符"><span class="nav-number">3.1.</span> <span class="nav-text">有些ASCII符号是不可显示的,如转义字符:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#n-换行符-r-回车-b-退格符-t-制表符-’-单引号-’’双引号-0-字符串结束符-f-分页符"><span class="nav-number">3.1.1.</span> <span class="nav-text">\n 换行符  ,\r 回车, \b  退格符,\t 制表符 ,\’ 单引号, \’’双引号, \0 字符串结束符, \f 分页符.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针-and-amp"><span class="nav-number">4.</span> <span class="nav-text">指针(*and&)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体指针"><span class="nav-number">5.</span> <span class="nav-text">结构体指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体指针访问结构体中变量中的成员"><span class="nav-number">5.1.</span> <span class="nav-text">结构体指针访问结构体中变量中的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete运算符-释放动态申请到的存储空间"><span class="nav-number">5.2.</span> <span class="nav-text">delete运算符:释放动态申请到的存储空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new运算符-gt-动态申请所需的内存空间"><span class="nav-number">5.3.</span> <span class="nav-text">new运算符->动态申请所需的内存空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象-amp-封装"><span class="nav-number">6.</span> <span class="nav-text">抽象&封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体和类的区别"><span class="nav-number">6.1.</span> <span class="nav-text">结构体和类的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-内联函数"><span class="nav-number">6.2.</span> <span class="nav-text">1.内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-在类体外定义函数成员"><span class="nav-number">6.3.</span> <span class="nav-text">2.在类体外定义函数成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向过程"><span class="nav-number">6.4.</span> <span class="nav-text">面向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">6.5.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">6.6.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Destructor-语法格式"><span class="nav-number">6.7.</span> <span class="nav-text">Destructor 语法格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-inheritance"><span class="nav-number">7.</span> <span class="nav-text">继承(inheritance)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的定义"><span class="nav-number">7.1.</span> <span class="nav-text">派生类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问权限"><span class="nav-number">7.2.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基类的constructor和destructor不能被继承"><span class="nav-number">7.3.</span> <span class="nav-text">基类的constructor和destructor不能被继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">8.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数"><span class="nav-number">9.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基类加入virtual的函数是虚函数-子类可以重写虚函数实现对父函数的覆盖"><span class="nav-number">9.0.1.</span> <span class="nav-text">基类加入virtual的函数是虚函数,子类可以重写虚函数实现对父函数的覆盖.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在计算机领域virtual的意思是用户看到的东西事实上并不存在-它只是用某种方法支撑的幻觉罢了-这里他的意思是不让用户看到事实上存在的东西-基类的成员函数"><span class="nav-number">9.0.2.</span> <span class="nav-text">在计算机领域virtual的意思是用户看到的东西事实上并不存在,它只是用某种方法支撑的幻觉罢了.这里他的意思是不让用户看到事实上存在的东西(基类的成员函数).</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不管怎么如果需要调用基类的成员函数可以使用下面的方法"><span class="nav-number">9.0.3.</span> <span class="nav-text">不管怎么如果需要调用基类的成员函数可以使用下面的方法:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么成员函数不缺省使用virtual"><span class="nav-number">9.0.4.</span> <span class="nav-text">为什么成员函数不缺省使用virtual?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">9.1.</span> <span class="nav-text">定义:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">9.2.</span> <span class="nav-text">格式:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用处"><span class="nav-number">9.3.</span> <span class="nav-text">用处:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用限制"><span class="nav-number">9.4.</span> <span class="nav-text">使用限制:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类"><span class="nav-number">10.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数定义"><span class="nav-number">10.1.</span> <span class="nav-text">纯虚函数定义:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚析构函数-通过基类指针可以释放派生类对象的空间"><span class="nav-number">10.2.</span> <span class="nav-text">虚析构函数:通过基类指针可以释放派生类对象的空间.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板"><span class="nav-number">11.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#根据函数实参中的类型来确认是否匹配函数模板中对应的形参-然后生成一个重载函数"><span class="nav-number">11.1.</span> <span class="nav-text">根据函数实参中的类型来确认是否匹配函数模板中对应的形参,然后生成一个重载函数.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入-输出流"><span class="nav-number">12.</span> <span class="nav-text">输入/输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打开文件"><span class="nav-number">12.1.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开文件用于输入"><span class="nav-number">12.2.</span> <span class="nav-text">打开文件用于输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开文件用于输出"><span class="nav-number">12.3.</span> <span class="nav-text">打开文件用于输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以二进制的形式打开文件-c-abc-bmp"><span class="nav-number">12.4.</span> <span class="nav-text">以二进制的形式打开文件 c:\abc.bmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制文件读写函数"><span class="nav-number">12.5.</span> <span class="nav-text">二进制文件读写函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制文件输入数据"><span class="nav-number">12.5.1.</span> <span class="nav-text">二进制文件输入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制文件输出数据"><span class="nav-number">12.5.2.</span> <span class="nav-text">二进制文件输出数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL-Standard-Template-Library"><span class="nav-number">13.</span> <span class="nav-text">STL(Standard Template Library)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">13.1.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#你有必要包含-maps是std命名空间的一部分-maps需要2到3种类型对于模板"><span class="nav-number">13.1.1.</span> <span class="nav-text">你有必要包含,maps是std命名空间的一部分,maps需要2到3种类型对于模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#需要调用一个erase函数进行删除map中的一个成员"><span class="nav-number">13.1.2.</span> <span class="nav-text">需要调用一个erase函数进行删除map中的一个成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#how-many-values-the-map-contains-by-using-the-size-function"><span class="nav-number">13.1.3.</span> <span class="nav-text">how many values the map contains by using the size function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#we-could-call-the-size-function-on-the-grade-list"><span class="nav-number">13.1.4.</span> <span class="nav-text">we could call the size function on the grade list:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#If-we’re-only-interested-in-whether-the-map-is-empty-we-can-just-use-the-map-member-function-empty"><span class="nav-number">13.1.5.</span> <span class="nav-text">If we’re only interested in whether the map is empty, we can just use the map member function empty:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#If-you-want-guarantee-that-the-map-is-empty-you-can-use-the-clear-function"><span class="nav-number">13.1.6.</span> <span class="nav-text">If you want guarantee that the map is empty, you can use the clear function.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个key是否在map中有对应的value-你需要调用find函数如果有这个key对应的value时将会返回一个iterator-如果没有发现key对应的value迭代器将会指向这个-map-name-end"><span class="nav-number">13.1.7.</span> <span class="nav-text">一个key是否在map中有对应的value,你需要调用find函数如果有这个key对应的value时将会返回一个iterator,如果没有发现key对应的value迭代器将会指向这个 map_name.end()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含两个成员-第一个对应的是key-第二个对应的是value-迭代器被当做是一个指针去访问成员变量-你需要用-gt-去取消引用这个迭代器"><span class="nav-number">13.1.8.</span> <span class="nav-text">包含两个成员,第一个对应的是key,第二个对应的是value,迭代器被当做是一个指针去访问成员变量,你需要用->去取消引用这个迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">13.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向量相对比较花费时间插入向量中-但是能够很快的进行随机访问-链表比较容易插入但是访问比较困难"><span class="nav-number">13.2.1.</span> <span class="nav-text">向量相对比较花费时间插入向量中,但是能够很快的进行随机访问,链表比较容易插入但是访问比较困难</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新的元素将会各自插在链表的开头和结尾用push-back-and-push-front-两个函数"><span class="nav-number">13.2.2.</span> <span class="nav-text">新的元素将会各自插在链表的开头和结尾用push_back and push_front 两个函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入需要一个迭代器指向这个元素应该被插入的位置-新的元素将会被插入当前指向的"><span class="nav-number">13.2.3.</span> <span class="nav-text">插入需要一个迭代器指向这个元素应该被插入的位置,新的元素将会被插入当前指向的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元素之前"><span class="nav-number">13.2.4.</span> <span class="nav-text">元素之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表返回一个迭代器在链表的第一个元素-返回一个迭代器在元素在链表的最后-你能声明一个迭代器作为其他对象的容器"><span class="nav-number">13.2.5.</span> <span class="nav-text">链表返回一个迭代器在链表的第一个元素,返回一个迭代器在元素在链表的最后,你能声明一个迭代器作为其他对象的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加一个元素与在链表的结尾也可以这样实现"><span class="nav-number">13.2.6.</span> <span class="nav-text">增加一个元素与在链表的结尾也可以这样实现:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表包含两个函数size-empty-size的时间复杂度是O-N-如果你想要测试一个链表是否为空用empty函数代替size函数-如果你想保证这个链表为空-就要用clear函数"><span class="nav-number">13.2.7.</span> <span class="nav-text">链表包含两个函数size,empty,size的时间复杂度是O(N),如果你想要测试一个链表是否为空用empty函数代替size函数,如果你想保证这个链表为空,就要用clear函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法仅仅提供能随机访问迭代器-不提供排序在链表容器中-这时候就有必要用成员函数进行排序了"><span class="nav-number">13.2.8.</span> <span class="nav-text">排序算法仅仅提供能随机访问迭代器,不提供排序在链表容器中,这时候就有必要用成员函数进行排序了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lists-can-be-reversed-using"><span class="nav-number">13.2.9.</span> <span class="nav-text">Lists can be reversed using</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其中一个特点-用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值"><span class="nav-number">13.2.10.</span> <span class="nav-text">其中一个特点,用逆序成员函数取代算法逆序是它不影响如果正在被其他迭代器指向的值.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#另外一个可能的用法链表的函数是一个成员函数被调用unique-删除链表中相同的元素最后只保留一个-如果你有一个链表包含如下"><span class="nav-number">13.2.11.</span> <span class="nav-text">另外一个可能的用法链表的函数是一个成员函数被调用unique,删除链表中相同的元素最后只保留一个,如果你有一个链表包含如下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-calling-unique-would-result-in-the-following-output-可以发现仍然还有两个8-仅仅挨着的两个元素其中一个被删除了"><span class="nav-number">13.2.12.</span> <span class="nav-text">the calling unique would result in the following output:可以发现仍然还有两个8,仅仅挨着的两个元素其中一个被删除了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你如果想要把相同的元素只保留一个-就需要先排序再调用unique函数"><span class="nav-number">13.2.13.</span> <span class="nav-text">你如果想要把相同的元素只保留一个,就需要先排序再调用unique函数.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器-amp-迭代器"><span class="nav-number">13.2.14.</span> <span class="nav-text">容器&迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的-include指示符的后面：using-namespace-std"><span class="nav-number">13.2.15.</span> <span class="nav-text">尽管你的编译器可能没有实现名字空间，你仍然可以使用他们。为了使用STL，可以将下面的指示符插入到你的源代码文件中，典型地是在所有的#include指示符的后面：using namespace std;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">13.2.16.</span> <span class="nav-text">参考资料:</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyao</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3XyhYMqxc2bwFHPrQqGqa5BO-gzGzoHsz", "CmQQXos7nqS2j3zgcIL5kbpC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
