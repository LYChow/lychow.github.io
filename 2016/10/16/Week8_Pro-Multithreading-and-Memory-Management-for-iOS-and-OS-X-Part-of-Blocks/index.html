<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Pro Multithreading and Memory Management for iOS and OS X Part of Blocks(第8周Research课题) | Life Is An Exploration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="BlockSyntaxAs a local variable:1returnType (^blockName)(parameterTypes) = ^returnType(parameters)&amp;#123;...&amp;#125;;
AS a property:1@property(nonatomic,copy,nullability) returnType(^blockName)(parameterT">
<meta property="og:type" content="article">
<meta property="og:title" content="Pro Multithreading and Memory Management for iOS and OS X Part of Blocks(第8周Research课题)">
<meta property="og:url" content="www.coderlychow.com/2016/10/16/Week8_Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X-Part-of-Blocks/index.html">
<meta property="og:site_name" content="Life Is An Exploration">
<meta property="og:description" content="BlockSyntaxAs a local variable:1returnType (^blockName)(parameterTypes) = ^returnType(parameters)&amp;#123;...&amp;#125;;
AS a property:1@property(nonatomic,copy,nullability) returnType(^blockName)(parameterT">
<meta property="og:updated_time" content="2016-10-16T01:43:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pro Multithreading and Memory Management for iOS and OS X Part of Blocks(第8周Research课题)">
<meta name="twitter:description" content="BlockSyntaxAs a local variable:1returnType (^blockName)(parameterTypes) = ^returnType(parameters)&amp;#123;...&amp;#125;;
AS a property:1@property(nonatomic,copy,nullability) returnType(^blockName)(parameterT">
  
    <link rel="alternate" href="/atom.xml" title="Life Is An Exploration" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Life Is An Exploration</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">只不过是一场游戏</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="www.coderlychow.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="_posts-Week8_Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X-Part-of-Blocks" class="article article-type-_posts" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/Week8_Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X-Part-of-Blocks/" class="article-date">
  <time datetime="2016-10-16T01:39:39.000Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Pro Multithreading and Memory Management for iOS and OS X Part of Blocks(第8周Research课题)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="BlockSyntax"><a href="#BlockSyntax" class="headerlink" title="BlockSyntax"></a>BlockSyntax</h3><h5 id="As-a-local-variable"><a href="#As-a-local-variable" class="headerlink" title="As a local variable:"></a>As a <strong>local variable</strong>:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters)&#123;...&#125;;</div></pre></td></tr></table></figure>
<h5 id="AS-a-property"><a href="#AS-a-property" class="headerlink" title="AS a property:"></a>AS a property:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,copy,nullability) returnType(^blockName)(parameterTypes);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="AS-a-method-parameter"><a href="#AS-a-method-parameter" class="headerlink" title="AS a method parameter:"></a>AS a method parameter:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)someMethodThatTakeABlcok:(returnType (^nullability)(parameterTypes))blockName;</div></pre></td></tr></table></figure>
<h5 id="As-a-argument-to-a-method-call"><a href="#As-a-argument-to-a-method-call" class="headerlink" title="As a argument to a method call:"></a>As a argument to a method call:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[someObject someMethodThatTakeABlcok:returnType(parameters)];</div></pre></td></tr></table></figure>
<h5 id="AS-a-typedef"><a href="#AS-a-typedef" class="headerlink" title="AS a typedef:"></a>AS a typedef:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">typedef returnType (^TypeName)(parameterTypes);</div><div class="line"></div><div class="line">TypeName blockName = ^returnType(parameters)&#123;...&#125;;</div></pre></td></tr></table></figure>
<p>Block语法与一般C语言函数定义相比,仅有两点不同:</p>
<blockquote>
<p>1.没有函数名(所以叫匿名函数)</p>
<p>2.带有”^”(插入记号),因为大量使用,所以插入该记号便于查找</p>
</blockquote>
<h4 id="省略返回值类型"><a href="#省略返回值类型" class="headerlink" title="省略返回值类型:"></a>省略返回值类型:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">^ 返回值类型  参数列表  表达式</div><div class="line">返回值类型省略:</div><div class="line">^ 参数列表 表达式</div></pre></td></tr></table></figure>
<p>省略返回值类型:</p>
<blockquote>
<p>1.如果表达式中有return语句就使用该返回值类型</p>
<p>2.如果表达式中没有return语句就是用void类型</p>
<p>3.当表达式中有多个return语句时,所有的return返回值类型必须相同</p>
</blockquote>
<h4 id="省略参数列表"><a href="#省略参数列表" class="headerlink" title="省略参数列表"></a>省略参数列表</h4><p>如果不适用参数,参数列表也能省略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">^void (void) &#123;printf(&quot;blocks&quot;);&#125;</div><div class="line"></div><div class="line">省略后的形式</div><div class="line"></div><div class="line">^&#123;printf(&quot;blocks&quot;);&#125;</div></pre></td></tr></table></figure>
<p>Block既指源代码中的block语法,也指由block语法所生成的值.</p>
<p>声明Block类型变量: int (^blk)(int);</p>
<p>使用Block语法将Block赋值为Block类型变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int (^blk)(int) = ^(int count)&#123;return count +1&#125;;</div></pre></td></tr></table></figure>
<h4 id="typedef定义Block"><a href="#typedef定义Block" class="headerlink" title="typedef定义Block"></a>typedef定义Block</h4><p>这种表达方式极为复杂,我们可以像使用函数类型指针那样,使用typedef来解决问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef int (^blk_t) (int);</div><div class="line"></div><div class="line">/原来的表达方式/</div><div class="line"></div><div class="line">void func(int (^blk) (int))</div><div class="line"></div><div class="line">/现在的表达方式/</div><div class="line"></div><div class="line">void func(blk_t blk);</div></pre></td></tr></table></figure>
<h4 id="block变量和C语言的其他变量一样使用"><a href="#block变量和C语言的其他变量一样使用" class="headerlink" title="block变量和C语言的其他变量一样使用"></a>block变量和C语言的其他变量一样使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">blk_t *blkptr = &amp;blk;</div><div class="line"></div><div class="line">(*blkptr)(10);</div></pre></td></tr></table></figure>
<h3 id="Block定义"><a href="#Block定义" class="headerlink" title="Block定义"></a>Block定义</h3><p>在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)。这样在objc中，block实际上就算是对象。编译器会根据block捕获的变量，生成具体的结构体定义。block内部的代码将会提取出来，成为一个单独的C函数。创建block时，实际就是在方法中声明一个struct，并且初始化该struct的成员。而执行block时，就是调用那个单独的C函数，并把该struct指针传递过去。block中包含了被引用的自由变量(由struct持有)，也包含了控制成分的代码块(由函数指针持有).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myBlock-&gt;impl.isa = &amp;_NSConcreteStackBlock;</div></pre></td></tr></table></figure>
<h3 id="为什么block捕获的局部变量不能更改"><a href="#为什么block捕获的局部变量不能更改" class="headerlink" title="为什么block捕获的局部变量不能更改?"></a>为什么block捕获的局部变量不能更改?</h3><blockquote>
<p>默认block捕获到的变量，都是赋值给block的结构体的，相当于const不可改。为了让block能访问并修改外部变量，需要加上_<em>block修饰词。</em></p>
<p>_当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。</p>
</blockquote>
<p>Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。</p>
<h4 id="在block中编译器在编译过程中检出给被截获自动变量赋值操作时-便产生编译错误-这样一来block中就不能保存值了极为不便-解决这个问题有两种方法允许Block修改值"><a href="#在block中编译器在编译过程中检出给被截获自动变量赋值操作时-便产生编译错误-这样一来block中就不能保存值了极为不便-解决这个问题有两种方法允许Block修改值" class="headerlink" title="在block中编译器在编译过程中检出给被截获自动变量赋值操作时,便产生编译错误.这样一来block中就不能保存值了极为不便.解决这个问题有两种方法允许Block修改值:"></a>在block中编译器在编译过程中检出给被截获自动变量赋值操作时,便产生编译错误.这样一来block中就不能保存值了极为不便.解决这个问题有两种方法允许Block修改值:</h4><blockquote>
<p>1.静态变量 静态全部变量  全局变量 (虽然Block语法的匿名函数部分简单地转换了C语言函数,但从这个转换的函数中访问静态变量 静态全部变量  全局变量并没有任何改变)</p>
<p>2.使用”<strong>block存储域类说明符”C语言下的存储域说明符有typedef ,exterm,static,auto,register,</strong>block说明符和这些说明符类似是用来指定将变量值设置到哪个存储域中,如auto表示作为自动变量存储在栈中,static表示作为静态变量储存在数据区中.我们使用__block说明符,用它来指定Block中想变更值的局部变量.</p>
</blockquote>
<h4 id="Block变量是否可修改注意事项"><a href="#Block变量是否可修改注意事项" class="headerlink" title="Block变量是否可修改注意事项:"></a>Block变量是否可修改注意事项:</h4><blockquote>
<p>1.静态存储区的变量：例如全局变量、方法中的static变量,引用，可修改。</p>
<p>2.block接受的参数传值，可修改，和一般函数的参数相同。</p>
<p>3.栈变量 (被捕获的上下文变量)const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。每次执行block时,捕获到的变量都是最初的值。</p>
<p>4.栈变量 (有__block前缀)引用，可以修改。如果时id类型则不会被block retain,必须手动处理其内存管理。如果该类型是C类型变量，block被copy到heap后,该值也会被挪动到heap</p>
</blockquote>
<h3 id="block从栈到堆"><a href="#block从栈到堆" class="headerlink" title="block从栈到堆?"></a>block从栈到堆?</h3><p>当函数返回时，函数的栈帧被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数。</p>
<p><a href="http://opensource.apple.com/source/libclosure/libclosure-63/runtime.c" target="_blank" rel="external">block苹果开源代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</div><div class="line"></div><div class="line">memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size);</div><div class="line"></div><div class="line">result-&gt;isa = _NSConcreteMallocBlock;</div><div class="line"></div><div class="line">_Block_call_copy_helper(result, aBlock);</div><div class="line"></div><div class="line">return result;</div></pre></td></tr></table></figure>
<p>####</p>
<h4 id="栈变量是如何自动生成将Block代码复制到堆上的"><a href="#栈变量是如何自动生成将Block代码复制到堆上的" class="headerlink" title="栈变量是如何自动生成将Block代码复制到堆上的?"></a>栈变量是如何自动生成将Block代码复制到堆上的?</h4><p>栈上的<strong>block变量用结构体实例在</strong>block变量从栈复制到堆上时,会将成员变量<strong>forwarding的值替换为复制目标堆上的</strong>block变量用结构体实例的地址.通过该功能,无论是在Block语法中,Block语法外使用<strong>block变量,还是</strong>block变量配置在栈上或堆上,都可以顺利访问同一个<strong>block变量.而</strong>block变量用结构体成员变量<strong>forwarding可以实现无论</strong>block变量配置在栈上还是堆上都能够正确的访问__block变量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tmp = _Block_copy(tmp);</div><div class="line">return objc_autoreleaseReturnValue(tmp);</div><div class="line">//将通过block语法生成的Block,配置在栈上的Block用结构体实例赋值给相当于Block类型的变量tmp中,</div><div class="line"></div><div class="line">tmp = _Block_copy(tmp);</div><div class="line">//_Block_copy函数将栈上的Block复制到堆上,复制后,将堆上的地址作为指针赋值给变量tmp.</div><div class="line">return objc_autoreleaseReturnValue(tmp);</div><div class="line">//将堆上的Block作为Objective-C对象注册到autoreleasepool中,然后返回该对象.</div></pre></td></tr></table></figure>
<h4 id="该源代码的blk-即Block在执行时发生异常应用程序强制结束-这是由于在getBlockArray函数执行结束时-栈上的block被废弃的缘故"><a href="#该源代码的blk-即Block在执行时发生异常应用程序强制结束-这是由于在getBlockArray函数执行结束时-栈上的block被废弃的缘故" class="headerlink" title="该源代码的blk(),即Block在执行时发生异常应用程序强制结束.这是由于在getBlockArray函数执行结束时,栈上的block被废弃的缘故."></a>该源代码的blk(),即Block在执行时发生异常应用程序强制结束.这是由于在getBlockArray函数执行结束时,栈上的block被废弃的缘故.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(id) getBlockArray</div><div class="line">&#123;</div><div class="line">return [[NSArray alloc]initWithObjects:^&#123;&#125;,^&#123;&#125;,nil];</div><div class="line">&#125;</div><div class="line">id obj =getBlockArray();</div><div class="line">typedef void (^blk_t) (void);</div><div class="line">blk_t blk = (blk_t)[obj objectAtIndex:0];</div><div class="line">blk();</div></pre></td></tr></table></figure>
<h3 id="block的作用"><a href="#block的作用" class="headerlink" title="__block的作用"></a>__block的作用</h3><h5 id="block所起到的作用就是只要观察到该变量被-block-所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”"><a href="#block所起到的作用就是只要观察到该变量被-block-所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”" class="headerlink" title="__block所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”."></a>__block所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">__block int a = 0;</div><div class="line">    NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区</div><div class="line">    void (^foo)(void) = ^&#123;</div><div class="line">        a = 1;</div><div class="line">        NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区</div><div class="line">    &#125;;</div><div class="line">    NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区</div><div class="line">    foo();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679]定义前：0x16fda86f8</div><div class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8</div><div class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8</div></pre></td></tr></table></figure>
<p>由于使用<strong>block变量结构体成员变量</strong>forwarding成员变量的原因,不管是__block变量在栈上还是堆上,都能够正确的访问该变量.</p>
<h4 id="如何证明block内部打印的是堆地址"><a href="#如何证明block内部打印的是堆地址" class="headerlink" title="如何证明block内部打印的是堆地址?"></a>如何证明block内部打印的是堆地址?</h4><p>把三个16进制的内存地址转成10进制就是：</p>
<blockquote>
<ol>
<li><p>定义后前：6171559672</p>
</li>
<li><p>block内部：5732708296</p>
<p>中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。</p>
</li>
</ol>
<p>但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__block int val =10;</div><div class="line">^(val = 1;)</div><div class="line">该源代码转换如下</div><div class="line">static void main_block_func_0(struct main_block_impl_0 *__cself)</div><div class="line">&#123;</div><div class="line">block_byref_val_0 *val = cself-&gt;val;</div><div class="line">(val-&gt;__forwarding-&gt;val) = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><p> 通过支持Block编译器,含有block语法的源代码转换成一般C语言源代码处理,实际上编译器无法转换成我们能够理解的源代码,但clang(LLVM编译器)具有转换成我们可读源代码的功能.使用”-rewrite-objc”选项就能将含有Block语法的源代码转换为C++的源代码,其实也仅仅是使用了Struct结构,本质上还是C语言源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc    源代码文件名</div></pre></td></tr></table></figure>
<h4 id="struct-main-block-impl-0-cself-参数cself是-main-block-impl-0结构体指针"><a href="#struct-main-block-impl-0-cself-参数cself是-main-block-impl-0结构体指针" class="headerlink" title="struct main_block_impl_0 *cself   参数cself是 main_block_impl_0结构体指针"></a>struct <strong>main_block_impl_0 *</strong>cself   参数<strong>cself是 </strong>main_block_impl_0结构体指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">struct _main_block_impl0</div><div class="line">&#123;</div><div class="line">struct __block_impl impl;</div><div class="line">struct _main_block_desc0* Desc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//__block_impl结构体声明</div><div class="line">struct __block_impl</div><div class="line">&#123;</div><div class="line">void *isa;</div><div class="line">int Flags;</div><div class="line">int Reserved;</div><div class="line">void *FuncPtr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//_main_block_desc0结构体声明</div><div class="line">struct _main_block_desc0 &#123;</div><div class="line">unsigned long reserved;</div><div class="line">unsigned long Block_size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="初始化-main-block-impl0结构体成员的源代码"><a href="#初始化-main-block-impl0结构体成员的源代码" class="headerlink" title="初始化__main_block_impl0结构体成员的源代码"></a>初始化__main_block_impl0结构体成员的源代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">main_block_impl_0(void *fp,struct main_block_desc_0 *desc ,int flags = 0)</div><div class="line">&#123;</div><div class="line">imp1.isa = &amp;NSConcreteStackBlock;  //NSConcreteStackBlock用于初始化__block_impl结构体的isa成员</div><div class="line">imp1.Flags = flag;</div><div class="line">imp1.FuncPtr = fp;</div><div class="line">Desc = desc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多个block使用同一个block变量"><a href="#多个block使用同一个block变量" class="headerlink" title="多个block使用同一个block变量"></a>多个block使用同一个block变量</h3><blockquote>
<p>1.任何一个Block从栈复制到堆上时</p>
<p>2.block变量也会一并从栈复制到堆并被该Block持有.</p>
<p>3.当剩余的Block从栈复制到堆时,剩余的这些Block也会持有这个<strong>block变量</strong></p>
<p>4.像Objective-C中的变量一样,会增加<strong>block的引用计数.如果堆上的Block被废弃,它引用的</strong>block变量也就被断开引用引用计数-1.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">__block int val =10;</div><div class="line"></div><div class="line">void (^blk0) (void) = ^&#123;val = 0;&#125;;</div><div class="line"></div><div class="line">void (^blk1) (void) = ^&#123;val =1;&#125;;</div><div class="line"></div><div class="line">Block类型的变量blk0,blk1访问__block变量val.我们把两部分的源代码转换结果摘录如下</div><div class="line"></div><div class="line">block_byref_val_0 val = &#123;0,&amp;val ,0,sizeof(block_byref_val_0),10&#125;;</div><div class="line"></div><div class="line">blk0 = &amp;main_block_impl_0(mian_block_func0,&amp;__mian_block_desc0_DATA,&amp;val,ox2220000);</div><div class="line"></div><div class="line">blk1 = &amp;main_block_impl_1(mian_block_func1,&amp;__mian_block_desc1_DATA,&amp;val,ox2220000);</div><div class="line"></div><div class="line">两个Block都使用了block_byref_val_0结构体实例val的指针.这样一来就可以从多个Block中使用同一个block变量.</div></pre></td></tr></table></figure>
<h3 id="类-设置对象的存储区"><a href="#类-设置对象的存储区" class="headerlink" title="类:设置对象的存储区"></a>类:设置对象的存储区</h3><p>_NSConcreteStackBlock:栈上</p>
<p>_NSConcreteGlobalBlock:程序的数据区上(.data区)</p>
<blockquote>
<p>因为使用全局变量的地方不能使用自动变量(栈上生成该结构体的实例),所以不存在对自动变量进行截取.整个程序只需要一个实例因此用Block结构体实例与全局变量在相同的数据区.</p>
</blockquote>
<p>_NSConcreteMallocBlock:堆</p>
<blockquote>
<p>设置在栈上的Block,如果其所属的变量作用域结束该Block就被废弃,由于<strong>block变量也配置在栈上,同样的其所属的作用域结束,则该</strong>block变量也会被废弃.Blocks提供了将Block和__block变量从栈上复制到堆上的方法来解决这个问题.将配置在栈上的Block复制到堆上,这样即使Block语法记述的变量作用域结束,堆上的Block还可以继续存在的.复制到堆上的Block将_NSConcreteMallocBlock类对象写入Block用结构体实例的成员变量isa.</p>
<p><code>impl.isa = &amp;_NSConcreteMallocBlock;</code></p>
</blockquote>
<h3 id="Block的副本"><a href="#Block的副本" class="headerlink" title="Block的副本"></a>Block的副本</h3><table>
<thead>
<tr>
<th>Block的类</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<h3 id="编译器不能管理结构体内存-运行时库可以管理其内存"><a href="#编译器不能管理结构体内存-运行时库可以管理其内存" class="headerlink" title="编译器不能管理结构体内存,运行时库可以管理其内存"></a>编译器不能管理结构体内存,运行时库可以管理其内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//C语言结构体不能含附有__strong修饰符的变量.因为编译器不知道如何应对C语言结构体的初始化和废弃,并不能管理结构体内存.</div><div class="line">struct _main_block_impl0</div><div class="line">&#123;</div><div class="line">struct __block_impl impl;</div><div class="line">struct _main_block_desc0* desc;</div><div class="line">id __strong array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>但是Objective-C运行时库能够准确的把握Block从栈复制到堆以及堆上的Block被废弃的时机.为此需要使用_main_block_desc_0结构体中增加的成员变量copy和dispose,以及作为指针赋值给该成员变量的<strong>main_block_copy_0函数和</strong>main_block_dispose_0函数.</p>
</blockquote>
<h4 id="copy函数和dispose函数的调用时机"><a href="#copy函数和dispose函数的调用时机" class="headerlink" title="copy函数和dispose函数的调用时机"></a>copy函数和dispose函数的调用时机</h4><p>copy函数的调用时机:栈上的Block复制到堆时.</p>
<blockquote>
<p>1.调用Block的copy实例方法时(如果Block配置在栈上,那么该Block会从栈复制到堆上)</p>
<p>2.Block作为函数的返回值返回时</p>
<p>3.将Block赋值给附有__strong修饰符id类型的类或Block类型的成员变量时(编译器自动地将对象的Block作为参数并调用_Block_copy函数)</p>
<p>4.在方法名含有usingBlock的cocoa框架 或GCD的API中传递Block时(在该方法或函数内部对传递过来的Block调用Block的copy实例方法或者_Block_copy函数)</p>
</blockquote>
<h4 id="dispose函数的调用时机-堆上的Block被废弃时"><a href="#dispose函数的调用时机-堆上的Block被废弃时" class="headerlink" title="dispose函数的调用时机:堆上的Block被废弃时"></a>dispose函数的调用时机:堆上的Block被废弃时</h4><p>对象和<strong>block变量转换后的源代码在Block用结构体的部分基本相同,那么我们怎么去区分他们呢?</strong></p>
<blockquote>
<p>对象:BLOCK_FIELD_IS_OBJECT</p>
<p>block变量:BLOCK_FIELD_IS_BYREF</p>
<p>用这两个参数区分copy函数和dispose函数的对象类型是对象还是__block变量.</p>
</blockquote>
<h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><h4 id="成员变量引起的循环引用"><a href="#成员变量引起的循环引用" class="headerlink" title="成员变量引起的循环引用"></a>成员变量引起的循环引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface MyObject : NSObject</div><div class="line">&#123;</div><div class="line">blk_t blk_;</div><div class="line">id obj_;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MyObject</div><div class="line">- (id)init </div><div class="line">&#123;</div><div class="line">self =[super init];</div><div class="line">blk^&#123;NSLog(@&quot;obj = %@&quot;,obj_);&#125;;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">//Block语法内使用obj实际上截获了self.对编译器来说,obj只不过是对象用结构体的成员变量.</div><div class="line">blk^&#123;NSLog(@&quot;obj = %@&quot;,obj_);&#125;;</div><div class="line">相当于下面</div><div class="line">blk_ = ^&#123;NSLog(@&quot;obj_ = %@&quot;,self-&gt;obj_);&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-block变量避免循环引用"><a href="#使用-block变量避免循环引用" class="headerlink" title="使用__block变量避免循环引用"></a>使用__block变量避免循环引用</h4><blockquote>
<p>ARC无效时,<strong>block说明符被用来避免Block中的循环引用.这是由于当Block从栈中复制到堆上时,若Block使用的变量为附有</strong>block说明符的id类型或对象类型的自动变量,不会被retain.,若Block使用的变量为没有__block说明符的id类型或对象类型的自动变量,就会被retain.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">typedef void (^blk_t) (void);</div><div class="line">@interface MyObject : NSObject</div><div class="line">&#123;</div><div class="line">blk_t blk_;//MyObject类对象持有Block</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implmentation MyObject</div><div class="line">- (id)init</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">block id tmp =self; //block变量持有MyObject类对象</div><div class="line">blk_ = ^&#123;</div><div class="line">NSLog(@&quot;self = %@&quot;,tmp);   //Block持有__block变量</div><div class="line">tmp =nil;</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)execBlock</div><div class="line">&#123;</div><div class="line">blk_();</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)dealloc</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;dealloc&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">id o =[[MyObject alloc]init];</div><div class="line">[o execBlock];</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如果不调用execBlock就会引起循环引用"><a href="#如果不调用execBlock就会引起循环引用" class="headerlink" title="如果不调用execBlock就会引起循环引用"></a>如果不调用execBlock就会引起循环引用</h5><blockquote>
<p>1.MyObject类对象持有Block</p>
<p>2.Block持有<strong>block变量</strong></p>
<p><strong>3.</strong>block变量持有MyObject类对象</p>
<p>这三个对象之间的引用会形成一个环,引起循环引用</p>
</blockquote>
<h5 id="此时我们调用execBlock方法-会发生什么样的事情呢"><a href="#此时我们调用execBlock方法-会发生什么样的事情呢" class="headerlink" title="此时我们调用execBlock方法,会发生什么样的事情呢?"></a>此时我们调用execBlock方法,会发生什么样的事情呢?</h5><blockquote>
<p>tmp=nil,__block变量不再持有MyObject类对象,循环引用被打破</p>
</blockquote>
<h3 id="copy-release"><a href="#copy-release" class="headerlink" title="copy/release"></a>copy/release</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//只要Block有一次复制并配置在堆上,就可以通过retain实例方法持有.</div><div class="line">[blk_on_heap retain];</div><div class="line"></div><div class="line">//但是对于配置在栈上的Block调用retain方法则不起作用.</div><div class="line">[blk_on_stack  retain];</div></pre></td></tr></table></figure>
<h4 id="虽然对赋值给blk-on-stack的栈上的Block调用了retain方法实例方法-但实际上对此源代码不起任何作用-因此推荐使用copy方法来持有Block"><a href="#虽然对赋值给blk-on-stack的栈上的Block调用了retain方法实例方法-但实际上对此源代码不起任何作用-因此推荐使用copy方法来持有Block" class="headerlink" title="虽然对赋值给blk_on_stack的栈上的Block调用了retain方法实例方法,但实际上对此源代码不起任何作用.因此推荐使用copy方法来持有Block."></a>虽然对赋值给blk_on_stack的栈上的Block调用了retain方法实例方法,但实际上对此源代码不起任何作用.因此推荐使用copy方法来持有Block.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//变量作用域结束时,变量array应该被废弃,其强引用失效.然而源代码运行正常并没有被废弃.</div><div class="line">blk_t blk;</div><div class="line">&#123;</div><div class="line">id array =[[NSMutableArray alloc]init];</div><div class="line">blk = [^(id obj)</div><div class="line">&#123;</div><div class="line">[array addObject:obj];</div><div class="line">&#125;copy];</div><div class="line">&#125;</div><div class="line">blk([[NSObject alloc]init]);</div><div class="line">//编译器不能判断是否需要复制,也可以不让编译器进行判断,而是在所有情况下都进行复制.但将block从栈上复制到堆上是相当耗费CPU的.当Block设置在栈上也能够使用时,将Block从栈上复制到堆上只是在浪费CPU资源.</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="http://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="external">objc 中的 block</a></p>
<p><a href="http://item.jd.com/11258970.html" target="_blank" rel="external">Objective-C高级编程 iOS与OS X多线程和内存管理</a></p>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="external">招聘一个靠谱的 iOS</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.coderlychow.com/2016/10/16/Week8_Pro-Multithreading-and-Memory-Management-for-iOS-and-OS-X-Part-of-Blocks/" data-id="civqmwyyt000qqbll79rbdmjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/10/16/Week8_brief-notes-about-house-form-renzhiqiang/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          brief notes about house form renzhiqiang(第8周Research课题-初版)
        
      </div>
    </a>
  
  
    <a href="/2016/10/10/Week3-English-Review-Methods/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">English Review Methods(第3周Research课题)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/20/Week12_The-Start-up-of-You-Executive-Summary/">The Start-up of You:Executive Summary(第12周Summary课题)</a>
          </li>
        
          <li>
            <a href="/2016/11/13/Week11_Gamification/">Gamification (第11周Research课题)</a>
          </li>
        
          <li>
            <a href="/2016/10/30/Week10_reading-skills-from-lixiaolai/">reading skills from lixiaolai(第10周Summary的课题)</a>
          </li>
        
          <li>
            <a href="/2016/10/30/Week10_Cpp-Grammar/">Cpp Grammar(第10周Summary的课题)</a>
          </li>
        
          <li>
            <a href="/2016/10/23/Week9_tips-about-house-from-lujun/">tips about house from lujun(第9周Research课题)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 daailychow<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>